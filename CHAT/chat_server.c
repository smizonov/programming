/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "chat.h"
using namespace std;
bool DataBaseRequest(string sql, sqlite3_stmt*& stmt, int &db_open_result, int &stmt_result);

result *
send_2_svc(send_params *argp, struct svc_req *rqstp)
{
	static result  result_send;
	sqlite3_stmt  *rows_stmt;
	int open_db, stmt_result;
	string sql, temp_str;
	sql = "SELECT ID FROM users WHERE login = '" + string(argp->to) + "';";
	if (!DataBaseRequest(sql, rows_stmt, open_db, stmt_result))
	{
		result_send.code = FAIL;
		temp_str = "ERROR: Database code " + to_string(open_db) + "  Prepare statement code " + to_string(stmt_result) + " end";
		result_send.descr = new char[temp_str.length()+1];
		strcpy(result_send.descr, temp_str.c_str());
		return &result_send;
	}
	if (sqlite3_step(rows_stmt) != SQLITE_ROW)
	{
		result_send.code = FAIL;
		sqlite3_finalize(rows_stmt);
		temp_str = "ERROR: User with name '" + string(argp->to) + "' does not exist.";
		result_send.descr = new char[temp_str.length()+1];
		strcpy(result_send.descr, temp_str.c_str());
		return &result_send;
	}
	sql = "INSERT INTO messages (sender, recipient, message) VALUES ('" + to_string(argp->cookie) + "', '" + to_string(sqlite3_column_int(rows_stmt, 0)) + "', '" + string (argp->message)+ "');";
	//sql = "INSERT INTO messages (sender, recipient, message) VALUES ('0','2','hello');";
	sqlite3_finalize(rows_stmt);
	if (!DataBaseRequest(sql, rows_stmt, open_db, stmt_result))
	{
		result_send.code = FAIL;
		temp_str = "ERROR: Database code " + to_string(open_db) + "  Prepare statement code " + to_string(stmt_result) + " end";
		result_send.descr = new char[temp_str.length()+1];
		strcpy(result_send.descr, temp_str.c_str());
		return &result_send;
	}
	sqlite3_step(rows_stmt);
	result_send.code = OK;
	temp_str = "Your message has been sent";
	result_send.descr = new char[temp_str.length()+1];
	strcpy(result_send.descr, temp_str.c_str());
	return &result_send;
}

login_result *
login_2_svc(login_params *argp, struct svc_req *rqstp)
{
	static login_result  result_log;
	sqlite3_stmt  *rows_stmt;
	int open_db, stmt_result;
	string sql, temp_str;
	bool st;
	sql = "SELECT ID, login, password FROM users WHERE login = '" + string(argp->login) + "' AND password = '" + std::string (argp->password) + "';";
	if (!DataBaseRequest(sql, rows_stmt, open_db, stmt_result))
	{
		result_log.res.code = FAIL;
		temp_str = "ERROR: Database code " + to_string(open_db) + "  Prepare statement code " + to_string(stmt_result) + " end";
		result_log.res.descr = new char[temp_str.length()+1];
		strcpy(result_log.res.descr, temp_str.c_str());
		return &result_log;
	}
	if(sqlite3_step(rows_stmt) == SQLITE_ROW)
	{
		result_log.res.code = OK;
		result_log.cookie = sqlite3_column_int(rows_stmt, 0);
		temp_str = "WELCOME " + string(argp->login) +" !";
		result_log.res.descr = new char[temp_str.length()+1];
		strcpy(result_log.res.descr, temp_str.c_str());	
		sqlite3_finalize(rows_stmt);
		sql = "UPDATE users SET status = 'online' WHERE login = '" + string(argp->login) + "' AND password = '" + std::string (argp->password) + "';";
		st = DataBaseRequest(sql, rows_stmt, open_db, stmt_result);
		sqlite3_step(rows_stmt);
		sqlite3_finalize(rows_stmt);
		return &result_log;
	} else {
		result_log.res.code = FAIL;
		temp_str = "ERROR: Incorrect login or password!";
		result_log.res.descr = new char[temp_str.length()+1];
		strcpy(result_log.res.descr, temp_str.c_str());
		result_log.cookie = sqlite3_column_int(rows_stmt, 0);
		return &result_log;
	}

	

	//return &result;
}

result *
logout_2_svc(logout_params *argp, struct svc_req *rqstp)
{
	static result  result_logout;
	sqlite3_stmt  *rows_stmt;
	int open_db, stmt_result;
	string sql, temp_str;
	sql = "UPDATE users SET status = 'offline' WHERE ID = '" + to_string(argp->cookie) + "';";
	if (!DataBaseRequest(sql, rows_stmt, open_db, stmt_result))
	{
		sqlite3_finalize(rows_stmt);
		result_logout.code = FAIL;
		temp_str = "ERROR: Database code " + to_string(open_db) + "  Prepare statement code " + to_string(stmt_result) + " end";
		result_logout.descr = new char[temp_str.length()+1];
		strcpy(result_logout.descr, temp_str.c_str());
		return &result_logout;		
	} else {
		sqlite3_step(rows_stmt);
		sqlite3_finalize(rows_stmt);
		result_logout.code = OK;
		temp_str = "DONE!";
		result_logout.descr = new char[temp_str.length()+1];
		strcpy(result_logout.descr, temp_str.c_str());
		return &result_logout;
	}
}

receive_result *
receive_2_svc(receive_params *argp, struct svc_req *rqstp)
{
	static receive_result  result_receive;
	sqlite3_stmt  *rows_stmt;
	int open_db, stmt_result;
	string sql, temp_str;
	sql = "SELECT users.login, messages.message FROM users INNER JOIN messages ON users.id = messages.sender "
          "WHERE messages.recipient = " + to_string (argp->cookie) + ";";
	if (!DataBaseRequest(sql, rows_stmt, open_db, stmt_result))
	{
		result_receive.res.code = FAIL;
		temp_str = "ERROR: Database code " + to_string(open_db) + "  Prepare statement code " + to_string(stmt_result) + " end";
		result_receive.res.descr = new char[temp_str.length()+1];
		strcpy(result_receive.res.descr, temp_str.c_str());
		return &result_receive;
	} else {
		int count_row=0;
		vector<string> name;
		vector<string> mess;
		while (sqlite3_step(rows_stmt) == SQLITE_ROW)
		{
			name.push_back(string(reinterpret_cast<const char*>(sqlite3_column_text(rows_stmt, 0))));
			mess.push_back(string(reinterpret_cast<const char*>(sqlite3_column_text(rows_stmt, 1))));
			count_row++;
		}
		result_receive.data.data_len=count_row;
		result_receive.data.data_val= new receive_message[count_row];
		for (int i = 0; i < count_row; ++i)
		{
			result_receive.data.data_val[i].from=new char[LOGIN_LEN];
			result_receive.data.data_val[i].message=new char[LOGIN_LEN];
			strcpy(result_receive.data.data_val[i].from, name[i].c_str());
			strcpy(result_receive.data.data_val[i].message, mess[i].c_str());
		}
		name.clear();
		mess.clear();
		sqlite3_finalize(rows_stmt);
		sql = "DELETE FROM messages WHERE recipient = " + to_string (argp->cookie) + ";";
		if (!DataBaseRequest(sql, rows_stmt, open_db, stmt_result))
		{
			result_receive.res.code = FAIL;
			temp_str = "ERROR: Database code " + to_string(open_db) + "  Prepare statement code " + to_string(stmt_result) + " end";
			result_receive.res.descr = new char[temp_str.length()+1];
			strcpy(result_receive.res.descr, temp_str.c_str());
			return &result_receive;			
		}
		else
		{
			sqlite3_step(rows_stmt);
			result_receive.res.code = OK;
			result_receive.res.descr = new char[RESULT_DESCR_LEN];
			temp_str = "Your messages";
			strcpy(result_receive.res.descr, temp_str.c_str());
			return &result_receive;
		}
	}

	
}

users_result *
users_2_svc(users_param *argp, struct svc_req *rqstp)
{
	static users_result  result_users;
	sqlite3_stmt  *rows_stmt;
	int open_db, stmt_result;
	string sql, temp_str;
	sql = "SELECT login, status FROM users";
	if (!DataBaseRequest(sql, rows_stmt, open_db, stmt_result))
	{
		result_users.res.code = FAIL;
		temp_str = "ERROR: Database code " + to_string(open_db) + "  Prepare statement code " + to_string(stmt_result) + " end";
		result_users.res.descr = new char[temp_str.length()+1];
		strcpy(result_users.res.descr, temp_str.c_str());
		return &result_users;
	} else {
		int count_row=0;
		vector<string> name;
		vector<string> stat;
		while (sqlite3_step(rows_stmt) == SQLITE_ROW)
		{
			//sql(sqlite3_column_text(rows_stmt, 0));
			name.push_back(string(reinterpret_cast<const char*>(sqlite3_column_text(rows_stmt, 0))));
			stat.push_back(string(reinterpret_cast<const char*>(sqlite3_column_text(rows_stmt, 1))));
			count_row++;
		}
		sqlite3_finalize(rows_stmt);
		result_users.data.data_len=count_row;
		result_users.data.data_val= new users_message[count_row];
		for (int i = 0; i < count_row; ++i)
		{
			result_users.data.data_val[i].login=new char[LOGIN_LEN];
			result_users.data.data_val[i].online=new char[LOGIN_LEN];
			strcpy(result_users.data.data_val[i].login, name[i].c_str());
			strcpy(result_users.data.data_val[i].online, stat[i].c_str());
		}
		name.clear();
		stat.clear();
		result_users.res.code = OK;
		result_users.res.descr = new char[RESULT_DESCR_LEN];
		temp_str = "Success, " + to_string(count_row) + " users shown";
		strcpy(result_users.res.descr, temp_str.c_str());
		return &result_users;
	}
}

result *
register_2_svc(register_params *argp, struct svc_req *rqstp)
{
	static result  result_reg;
	string sql, temp_str;
	sqlite3_stmt  *rows_stmt;
	int open_db, stmt_result;
	cout<<"\n REGISTRATION\n";
	sql = "SELECT COUNT(ID) FROM users WHERE login = '" + string(argp->login) + "';";

	if (!DataBaseRequest(sql, rows_stmt, open_db, stmt_result))
	{
		result_reg.code = FAIL;
		temp_str = "ERROR: Database code " + to_string(open_db) + "  Prepare statement code " + to_string(stmt_result) + " end";
		result_reg.descr = new char[temp_str.length()+1];
		strcpy(result_reg.descr, temp_str.c_str());
		return &result_reg;
	}
	sqlite3_step(rows_stmt);
	if (sqlite3_column_int(rows_stmt, 0) >0)
	{
		result_reg.code = FAIL;
		temp_str = "ERROR: user with the same name already exists";
		result_reg.descr = new char[temp_str.length()+1];
		strcpy(result_reg.descr, temp_str.c_str());
		return &result_reg;
	}
	sqlite3_finalize(rows_stmt);	
	sql = "SELECT COUNT(ID) FROM users;";
	if (!DataBaseRequest(sql, rows_stmt, open_db, stmt_result))
	{
		result_reg.code = FAIL;
		temp_str = "ERROR: Database code " + to_string(open_db) + "  Prepare statement code " + to_string(stmt_result) + " end";
		result_reg.descr = new char[temp_str.length()+1];
		strcpy(result_reg.descr, temp_str.c_str());
		return &result_reg;
	}
	sqlite3_step(rows_stmt);
	sql = "INSERT INTO users (ID, login, password, status) VALUES ('" + to_string(sqlite3_column_int(rows_stmt, 0)) + "', '" + string (argp->login) + "', '" + string (argp->password) + "', 'offline');";
	sqlite3_finalize(rows_stmt);
	if (!DataBaseRequest(sql, rows_stmt, open_db, stmt_result))
	{
		result_reg.code = FAIL;
		temp_str = "ERROR: Database code " + to_string(open_db) + "  Prepare statement code " + to_string(stmt_result) + " end";
		result_reg.descr = new char[temp_str.length()+1];
		strcpy(result_reg.descr, temp_str.c_str());
		return &result_reg;	
	}
	sqlite3_step(rows_stmt);
	sqlite3_finalize(rows_stmt);
	result_reg.code = OK;
	temp_str = "Register success!";
	result_reg.descr = new char[temp_str.length()+1];
	strcpy(result_reg.descr, temp_str.c_str());
	return &result_reg;
}

bool DataBaseRequest(string sql, sqlite3_stmt*& stmt, int &db_open_result, int &stmt_result)
{
	sqlite3 *db;
	db_open_result = sqlite3_open("chat4.db", &db);
	sqlite3_stmt *stmt1;
	stmt_result = sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, NULL);
	sqlite3_close(db);
	if(db_open_result)
		cout<<"\nCan't open database: "<<sqlite3_errmsg(db)<<endl;
	if(stmt_result)
		cout<<"\n!!!   Error prepare statement   !!!\n";
	if(db_open_result==0 && stmt_result==0)
		return true;
	else
		return false;
}
